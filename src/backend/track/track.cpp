#include "track.h"

#include "backend/utils/time.h"
#include <cmath>


std::string drop_ns(const std::string& name) {
    auto pos = name.rfind(':');
    return (pos == std::string::npos) ? name : name.substr(pos + 1);
}

namespace telemetry {
namespace track {
namespace consts {
    namespace mask {
        const field_id_t virtual_flag     = 0x80000000;
        const field_id_t metadata_flag    = 0x40000000;
        const field_id_t trackpoint_flag  = 0x20000000;
        const field_id_t segment_flag     = 0x10000000;
      /*   unused 0x08 flag                 0x08000000 */ 
      /*   unused 0x04 flag                 0x04000000 */
        const field_id_t lerp_flag        = 0x02000000;
        const field_id_t pchip_flag       = 0x01000000;

        namespace segment {
            const field_id_t type         = 0x00F80000; // up to 32 segment types
            const field_id_t list         = 0x00070000; // up to 8 segment lists
            const field_id_t segment      = 0x0000FF00; // up to 256 segment instances (within type-list context)
            const field_id_t field        = 0x000000FF; // up to 256 fields (within segment point/segment metadata)
        }
    }
    namespace prefix {
        const std::string metadata = "meta_";
        const std::string trackpoint = "point_";
        const std::string lerp = "lerp_";
        const std::string pchip = "pchip_";
        const std::string segment = "s_";
    } // namespace prefix
} // namespace consts


struct segment_field_id {
    field_id_t type;
    field_id_t list;
    field_id_t segment;
    field_id_t field;

    segment_field_id(field_id_t type, field_id_t list, field_id_t segment, field_id_t field)
        : type(type), list(list), segment(segment), field(field) {}

    segment_field_id(field_id_t fid) {
        type = (fid & consts::mask::segment::type) >> 19;
        list = (fid & consts::mask::segment::list) >> 16;
        segment = (fid & consts::mask::segment::segment) >> 8;
        field = fid & consts::mask::segment::field;
    }

    explicit operator field_id_t() const {
        return ((type << 19) & consts::mask::segment::type) |
               ((list << 16) & consts::mask::segment::list) |
               ((segment << 8) & consts::mask::segment::segment) |
               (field & consts::mask::segment::field);
    }
};

    //                          xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx
    //                         |--flags--|
    
    // field types:
    // virtual         0x80     1000 .... |-----------field-id------------|
    // metadata        0x40     0100 .... |-----------field-id------------|
    // trackpt         0x20     0010 .... |-----------field-id------------|
    // segment         0x10     0001 .... 

    // modifiers:
    // lerp            0x08     00.. 10..
    // pchip           0x04     00.. 01..
    // unused          0x02     .... ..1 
    // unused          0x01     .... ...1


    // segment field id layout:
    //                          0001 ..00  TTTT TLLL NNNN NNNN  IIII IIII
    //
    // examples (not real bit values):
    // s_climb_prev_1_dist      0001 0000  0001 0001 0000 0001  0001 0010
    //    type = 0x01  segment
    //    mods = 0x00  (no modifiers)
    //    type = 0x01* climb 
    //    list = 0x01  previous segments list
    //    num  = 0x01  first climb instance in prev list (most recently finished)
    //    field= 0x12* "dist" field within segment
    //
    // * - value autogenerated from track data
    //
    // lerp_s_climb_1_dist      0001 1000  0001 0000 0000 0001  0001 0010
    //    type = 0x10  segment
    //    mods = 0x08  linearly interpolated
    //    type = 0x01* climb
    //    list = 0x00  current segments list
    //    num  = 0x01  first climb instance in current list (oldest start time of currently active)
    //    field= 0x12* "dist" field within segment

    // TTTT       - segment type identifier (up to 16 types)
    // r          - reserved for future use
    // LLL        - segment list identifier (up to 8 lists)
    // NNNN NNNN  - segment instance identifier (up to 256 instances)
    // IIII IIII  - field identifier within segment (up to 256 fields)
    // 
    // segments types (TTTT) - mapped to TYPE in "s_TYPE_" field name prefix:
    //      auto generated from track
    //      e.g. "segment" "climb" generated by GPST in ActivitySegmentType extension
    //      in future e.g. "laps"
    //
    // segment lists (LLL):
    //     - currently active segment   (mapped to "s_TYPE_active_N_")
    //     - previous active segment    (mapped to "s_TYPE_prev_N_")
    //     - next active segment        (mapped to "s_TYPE_next_N_")
    //     - all segments               (mapped to "s_TYPE_N_")
    //
    // segment instance id (NNN NNNN) - mapped to N in field name prefix above:
    //     unique identifier for segment instance within its type-list
    //
    // field id within segment (IIII IIII) - mapped to field name after segment prefix
    //     generated from track point field names within segment context
    //     with cumulative values virtualized to treat segment start as zero point


Track::Track(time::microseconds_t offset): start_offset_(offset) {
    log.info("Track created with offset: {} us", offset);

    create_virtual_fields();
}

bool Track::load(const std::string& path) {
    log.info("Loading track from path: {}", path);

    pugi::xml_document doc;
    pugi::xml_parse_result result = doc.load_file(path.c_str());

    if (!result) {
        log.error("Failed to load track file: {}. Error description: {}", path, result.description());
        return false;
    }

    if (doc.children().empty()) {
        log.error("Empty track file: {}", path);
        return false;
    }

    if (std::distance(doc.children().begin(), doc.children().end()) > 1) {
        log.error("More than one root node in track file");
        return false;
    }

    pugi::xml_node root = doc.child("gpx");
    if (!root) {
        log.error("No <gpx> root node found in track file");
        return false;
    }

    bool ok = parse_gpx(root);

    return ok;
}

field_id_t Track::get_field_id(const std::string& field_name) const {
    auto it = field_ids_.find(field_name);
    if (it != field_ids_.end()) {
        return it->second;
    }
    return INVALID_FIELD;
}

Track::trackpoint_ts_view_t Track::get_trackpoint_timestamps() const {
    return std::views::keys(trackpoints_);
}

Value Track::get(const std::string& key, time::microseconds_t timestamp) const {
    field_id_t field_id = get_field_id(key);
    return get(field_id, timestamp);
}

Value Track::get(field_id_t field_id, time::microseconds_t timestamp) const {
    if (field_id == INVALID_FIELD) {
        log.warning("Invalid field id requested");
        return Value();
    } else if (field_id & consts::mask::segment_flag) {
        if (field_id & consts::mask::metadata_flag) {
            log.warning("Segment metadata retrieval not implemented yet");
            return Value();
        } else if (field_id & consts::mask::lerp_flag) {
            log.warning("Segment lerp data retrieval not implemented yet");
            return Value();
        } else if (field_id & consts::mask::pchip_flag) {
            log.warning("Segment pchip data retrieval not implemented yet");
            return Value();
        } else {
            log.warning("Segment field data retrieval not implemented yet");
            return Value();
        }
    } else if (field_id & consts::mask::trackpoint_flag) {
        if (field_id & consts::mask::lerp_flag) {
            return get_lerp_trackpoint_data(field_id, timestamp);
        } else if (field_id & consts::mask::pchip_flag) {
            return get_pchip_trackpoint_data(field_id, timestamp);
        } else {
            return get_trackpoint_data(field_id, timestamp);
        }
    } else if (field_id & consts::mask::metadata_flag) {
        return get_metadata(field_id);
    } else if (field_id & consts::mask::virtual_flag) {
        return get_virtual_data(field_id, timestamp);
    } else {
        log.warning("Unknown field id: {}", field_id);
        return Value();
    }
}

Value Track::get_metadata(const std::string& key) const {
    field_id_t field_id = get_field_id(key);
    return get_metadata(field_id);
}

Value Track::get_metadata(field_id_t field_id) const {
    auto it = metadata_.find(field_id);
    if (it != metadata_.end()) {
        return it->second;
    }
    return Value();
}

Value Track::get_trackpoint_data(const std::string& key, time::microseconds_t timestamp) const {
    field_id_t field_id = get_field_id(key);
    return get_trackpoint_data(field_id, timestamp);
}

Value Track::get_trackpoint_data(field_id_t field_id, time::microseconds_t timestamp) const {
    //TODO add caching of last accessed trackpoint (or similar)
    //TODO need to handle case where the data is stale?

    auto tp_it = trackpoints_.upper_bound(timestamp);

    if (tp_it != trackpoints_.begin()) {
        --tp_it;

        auto& tp_data = *(tp_it->second);
        auto field_it = tp_data.find(field_id);
        if (field_it != tp_data.end()) {
            return field_it->second;
        }
    }
    return Value();
}

Value Track::get_lerp_trackpoint_data(const std::string& key, time::microseconds_t timestamp) const {
    field_id_t field_id = get_field_id(key);
    return get_lerp_trackpoint_data(field_id, timestamp);
}

Value Track::get_lerp_trackpoint_data(field_id_t field_id, time::microseconds_t timestamp) const {
    field_id_t data_field_id = field_id ^ consts::mask::lerp_flag;

    auto upper_it = trackpoints_.upper_bound(timestamp);
    if (upper_it != trackpoints_.begin() && upper_it != trackpoints_.end()) {
        auto lower_it = std::prev(upper_it);

        auto& lower_data = *(lower_it->second);
        auto& upper_data = *(upper_it->second);

        auto lower_field_it = lower_data.find(data_field_id);
        auto upper_field_it = upper_data.find(data_field_id);

        if (lower_field_it != lower_data.end() && upper_field_it != upper_data.end()) {
            Value lower_value = lower_field_it->second;
            Value upper_value = upper_field_it->second;

            if (lower_value.is_double() && upper_value.is_double()) {
                double lv = lower_value.as_double();
                double uv = upper_value.as_double();

                time::microseconds_t t0 = lower_it->first;
                time::microseconds_t t1 = upper_it->first;

                double factor = static_cast<double>(timestamp - t0) / static_cast<double>(t1 - t0);
                double interpolated_value = lv + factor * (uv - lv);

                return Value(interpolated_value);
            } else {
                log.warning("Lerp interpolation only supported for double values. Field id: {}", data_field_id);
            }
        }
        else {
            log.debug("Field id {} not found in both bounding trackpoints for lerp interpolation", data_field_id);
        }
    } else {
        log.debug("Not enough trackpoints for lerp interpolation at timestamp {}", timestamp);
    }
    return Value();
}

Value Track::get_pchip_trackpoint_data(const std::string& key, time::microseconds_t timestamp) const {
    field_id_t field_id = get_field_id(key);
    return get_pchip_trackpoint_data(field_id, timestamp);
}

Value Track::get_pchip_trackpoint_data(field_id_t field_id, time::microseconds_t timestamp) const {
    field_id_t data_field_id = field_id ^ consts::mask::pchip_flag;

    auto it2 = trackpoints_.upper_bound(timestamp);
    auto it1 = (it2 != trackpoints_.begin()) ? std::prev(it2) : trackpoints_.end();
    auto it0 = (it1 != trackpoints_.begin()) ? std::prev(it1) : trackpoints_.end();
    auto it3 = (it2 != trackpoints_.end()) ? std::next(it2) : trackpoints_.end();

    if (it0 == trackpoints_.end() || it1 == trackpoints_.end() ||
        it2 == trackpoints_.end() || it3 == trackpoints_.end()) {
        log.debug("Not enough trackpoints for PCHIP interpolation at timestamp {}", timestamp);
        return Value();
    }

    auto data_it0 = it0->second->find(data_field_id);
    auto data_it1 = it1->second->find(data_field_id);
    auto data_it2 = it2->second->find(data_field_id);
    auto data_it3 = it3->second->find(data_field_id);

    if (data_it0 == it0->second->end() || data_it1 == it1->second->end() ||
        data_it2 == it2->second->end() || data_it3 == it3->second->end()) {
        log.debug("Field id {} not found in all bounding trackpoints for PCHIP interpolation", data_field_id);
        return Value();
    }

    if (it0->first >= it1->first || it1->first >= it2->first || it2->first >= it3->first) {
        log.error("Timestamps for PCHIP interpolation are not strictly increasing");
        return Value();
    }

    if (timestamp < it1->first || timestamp > it2->first) {
        log.error("Timestamp {} for PCHIP interpolation is out of bounds [{}, {}]", timestamp, it1->first, it2->first);
        return Value();
    }

    double t = time::us_to_s(timestamp);

    double t0 = time::us_to_s(it0->first);
    double t1 = time::us_to_s(it1->first);
    double t2 = time::us_to_s(it2->first);
    double t3 = time::us_to_s(it3->first);

    if (t == t1) {
        return Value(data_it1->second);
    }
    if (t == t2) {
        return Value(data_it2->second);
    }

    double x0 = data_it0->second.as_double();
    double x1 = data_it1->second.as_double();
    double x2 = data_it2->second.as_double();
    double x3 = data_it3->second.as_double();

    //pchip interpolation algorithm

    // intervals
    double h0 = t1 - t0;
    double h1 = t2 - t1;
    double h2 = t3 - t2;

    // secant slopes
    double d0 = (x1 - x0) / h0;
    double d1 = (x2 - x1) / h1;
    double d2 = (x3 - x2) / h2;

    // derivative at t1
    double m1 = 0;
    if (d0 * d1 > 0) {
        m1 = (h0 + h1) / ((h1 / d0) + (h0 / d1));
    }

    // defivative at t2
    double m2 = 0;
    if (d1 * d2 > 0) {
        m2 = (h1 + h2) / ((h2 / d1) + (h1 / d2));
    }

    // normalized parameter
    double s = (t - t1) / h1;

    // hermite basiss
    double h00 = 2 * std::pow(s, 3) - 3 * std::pow(s, 2) + 1;
    double h10 = std::pow(s, 3) - 2 * std::pow(s, 2) + s;
    double h01 = -2 * std::pow(s, 3) + 3 * std::pow(s, 2);
    double h11 = std::pow(s, 3) - std::pow(s, 2);

    // interpolated value
    double x = h00 * x1 + h10 * h1 * m1 + h01 * x2 + h11 * h1 * m2;

    return Value(x);
}

Value Track::get_virtual_data(const std::string& key, time::microseconds_t timestamp) const {
    field_id_t field_id = get_field_id(key);
    return get_virtual_data(field_id, timestamp);
}

Value Track::get_virtual_data(field_id_t field_id, time::microseconds_t timestamp) const {
    auto it = virtual_data_mapping_.find(field_id);
    if (it != virtual_data_mapping_.end()) {
        return it->second(timestamp);
    }

    log.warning("Unknown virtual field id: {}", field_id);
    return Value();
}

bool Track::parse_gpx(pugi::xml_node node) {
    log.info("Parsing GPX root node");

    bool ok = true;

    pugi::xml_node metadata = node.child("metadata");
    if (metadata) {
        ok = parse_metadata(metadata) && ok;
    }

    pugi::xml_node trk = node.child("trk");
    if (trk) {
        ok = parse_trk(trk) && ok;
    }

    return ok;
}


bool Track::parse_metadata(pugi::xml_node node) {
    log.info("Parsing GPX metadata");

    auto bounds = node.child("bounds");
    if (bounds) {
        auto minlat = bounds.attribute("minlat");
        if (minlat) {
            double value = minlat.as_double();
            log.debug("Metadata minlat: {}", value);
            store_metadata("minlat", value);
        }
        auto maxlat = bounds.attribute("maxlat");
        if (maxlat) {
            double value = maxlat.as_double();
            log.debug("Metadata maxlat: {}", value);
            store_metadata("maxlat", value);
        }
        auto minlon = bounds.attribute("minlon");
        if (minlon) {
            double value = minlon.as_double();
            log.debug("Metadata minlon: {}", value);
            store_metadata("minlon", value);
        }
        auto maxlon = bounds.attribute("maxlon");
        if (maxlon) {
            double value = maxlon.as_double();
            log.debug("Metadata maxlon: {}", value);
            store_metadata("maxlon", value);
        }
    }

    auto name = node.child("name");
    if (name) {
        log.debug("Metadata name: {}", name.text().as_string());
        store_metadata("name", std::string(name.text().as_string()));
    }

    return true;
}

bool Track::parse_trk(pugi::xml_node node) {
    log.info("Parsing GPX track");

    auto name = node.child("name");
    if (name) {
        log.debug("Track name: {}", name.text().as_string());
        store_metadata("name", std::string(name.text().as_string()));
    }
    auto src = node.child("src");
    if (src) {
        log.debug("Track src: {}", src.text().as_string());
        store_metadata("src", std::string(src.text().as_string()));
    }
    auto type = node.child("type");
    if (type) {
        log.debug("Track type: {}", type.text().as_string());
        store_metadata("type", std::string(type.text().as_string()));
    }

    start_time_ = find_start_time(node.children("trkseg"));
    if (start_time_ == time::INVALID_TIME_POINT) {
        log.error("Failed to find valid start timestamp in track");
        return false;
    }
    log.info("Track start time: {}", std::format("{}", start_time_));

    bool ok = true;

    auto extensions = node.child("extensions");
    if (extensions) {
        ok = parse_trk_ext(extensions) && ok;
    }

    for (auto trkseg: node.children("trkseg")) {
        ok = parse_trkseg(trkseg) && ok;
    }

    return ok;
}

time::time_point_t Track::find_start_time(
                pugi::xml_object_range<pugi::xml_named_node_iterator> trksegs) {
    time::time_point_t st = time::INVALID_TIME_POINT;
    for (auto trkseg: trksegs) {
        for (auto trkpt : trkseg.children("trkpt")) {
            if (trkpt.child("time")) {
                std::string time_str = trkpt.child("time").text().as_string();
                auto timestamp = time::parse_iso8601(time_str);
                if (timestamp != time::INVALID_TIME_POINT) {
                    if (st == time::INVALID_TIME_POINT || timestamp < st) {
                        st = timestamp;
                    }
                }
            }
        }
    }
    return st;
}

bool Track::parse_trk_ext(pugi::xml_node node) {
    log.info("Parsing GPX track extensions");
    bool ok = true;
    
    for (pugi::xml_node child : node.children()) {
        if (std::string(child.name()).ends_with("ActivityTrackExtension")) {
            ok = parse_trk_ext_atx(child) && ok;
        } else if (std::string(child.name()).ends_with("ActivitySegmentsExtension")) {
            ok = parse_trk_ext_asx(child) && ok;
        } else {
            log.info("Ignoring unknown track extension: {}", child.name());
        }
    }

    return ok;
}

bool Track::parse_trk_ext_atx(pugi::xml_node node) {
    log.info("Parsing GPX ActivityTrackExtension");
    bool ok = true;

    int cnt = 0;
    for (pugi::xml_node child : node.children()) {
        std::string key =drop_ns(child.name());
        double value = child.text().as_double();

        log.debug("Metadata: {} = {}", key, value);
        store_metadata(key, value);
        cnt++;
    }
    log.info("Parsed {} ActivityTrackExtension fields", cnt);

    return ok;
}

bool Track::parse_trk_ext_asx(pugi::xml_node node) {
    log.info("Parsing GPX ActivitySegmentsExtension");
    // TODO implement parsing of ActivitySegmentsExtension

    // segments LUT:
    //
    // std::map<field_id_t, std::map<field_id_t, std::pair<time::microseconds_t, time::microseconds_t>>>
    // segments[segment_type_id][segment_instance] = {start_time, end_time}
    //
    // maps to all segments list prefix: "s_TYPE_N_"
    //     TYPE - segment_type_id
    //     N    - segment_instance

    return true;
}

bool Track::parse_trkseg(pugi::xml_node node) {
    log.info("Parsing GPX track segment");
    bool ok = true;

    for (pugi::xml_node trkpt : node.children("trkpt")) {
        ok = parse_trkpt(trkpt) && ok;
    }

    return ok;
}

bool Track::parse_trkpt(pugi::xml_node node) {
    log.debug("Parsing GPX track point");

    if (!node.attribute("lat") || !node.attribute("lon")) {
        log.warning("Track point missing lat or lon attribute");
        return false;
    }
    if (!node.child("time")) {
        log.warning("Track point missing time value");
        return false;
    }

    std::string time_str = node.child("time").text().as_string();
    auto timestamp = time::parse_iso8601(time_str);
    if (timestamp == time::INVALID_TIME_POINT) {
        log.warning("Failed to parse track point time: {}", time_str);
        return false;
    }
    log.debug("Track point time: {}", timestamp);

    time::microseconds_t ts = to_relative_time_domain(timestamp);

    store_trackpoint_data(ts, "time", Value(timestamp));

    double lat = node.attribute("lat").as_double();
    double lon = node.attribute("lon").as_double();
    store_trackpoint_data(ts, "lat", Value(lat));
    store_trackpoint_data(ts, "lon", Value(lon));
    log.debug("Track point lat: {}, lon: {}", lat, lon);

    for (pugi::xml_node child : node.children()) {
        std::string key = drop_ns(child.name());
        if (key == "time") {
            continue; // processed separately
        }
        if (key == "extensions") {
            for (pugi::xml_node ext_child : child.children()) {
                std::string ext_key = drop_ns(ext_child.name());
                if (ext_key == "TrackPointExtension" || ext_key == "ActivityTrackPointExtension") {
                    for (pugi::xml_node ext_data : ext_child.children()) {
                        std::string data_key = drop_ns(ext_data.name());
                        if (ext_data.text().empty()) {
                            log.debug("Track point extension data: {} has no data", data_key);
                            continue; // no data
                        }
                        double value = ext_data.text().as_double();
                        log.debug("Track point extension data: {} = {}", data_key, value);
                        store_trackpoint_data(ts, data_key, Value(value));
                    }
                } else if (ext_key == "power") { // special case for Strava gpx files
                    if (ext_child.text().empty()) {
                        log.debug("Track point extension data: power has no data");
                        continue; // no data
                    }
                    double value = ext_child.text().as_double();
                    log.debug("Track point extension data: power = {}", value);
                    store_trackpoint_data(ts, "power", Value(value));
                } else {
                    log.debug("Ignoring unknown track point extension: {}", ext_key);
                }
            }
            continue; // processed
        }
        if (child.text().empty()) {
            log.debug("Track point data: {} has no data", key);
            continue; // no data
        }
        double value = child.text().as_double();
        log.debug("Track point data: {} = {}", key, value);
        store_trackpoint_data(ts, key, Value(value));
    }

    return true;
}

bool Track::store_metadata(const std::string& key, const Value& value) {
    field_id_t field_id = register_metadata_field(key);
    metadata_[field_id] = value;
    return true;
}

bool Track::store_trackpoint_data(time::microseconds_t timestamp,
                                  const std::string& key, const Value& value) {
    std::shared_ptr<std::map<field_id_t, Value>> tp_data;
    
    auto it = trackpoints_.find(timestamp);
    if (it != trackpoints_.end()) {
        tp_data = it->second;
    } else {
        tp_data = std::make_shared<std::map<field_id_t, Value>>();
        trackpoints_[timestamp] = tp_data;

        if (timestamp < min_timestamp_) {
            min_timestamp_ = timestamp;
        }
        if (timestamp > max_timestamp_) {
            max_timestamp_ = timestamp;
        }
    }

    field_id_t field_id = register_trackpoint_field(key);
    (*tp_data)[field_id] = value;
    return true;
}

void Track::create_virtual_fields() {
    virtual_data_mapping_[register_virtual_field("timestamp")] = [this](time::microseconds_t timestamp) -> Value {
        time::time_point_t tp = start_time_ + std::chrono::microseconds(timestamp - start_offset_);
        return Value(tp);
    };

    virtual_data_mapping_[register_virtual_field("video_time")] = [this](time::microseconds_t timestamp) -> Value {
        return Value(time::us_to_s(timestamp));
    };

    virtual_data_mapping_[register_virtual_field("time_elapsed")] = [this](time::microseconds_t timestamp) -> Value {
        if (min_timestamp_ != time::INVALID_TIME) {
            return Value(time::us_to_s(timestamp - min_timestamp_));
        } else {
            return Value();
        }
    };

    virtual_data_mapping_[register_virtual_field("time_remaining")] = [this](time::microseconds_t timestamp) -> Value {
        if (max_timestamp_ != 0) {
            return Value(time::us_to_s(max_timestamp_ - timestamp));
        } else {
            return Value();
        }
    };

    virtual_data_mapping_[register_virtual_field("active")] = [this](time::microseconds_t timestamp) -> Value {
        if (min_timestamp_ != time::INVALID_TIME && max_timestamp_ != 0) {
            return Value(timestamp >= min_timestamp_ && timestamp <= max_timestamp_);
        } else {
            return Value(false);
        }
    };

    virtual_data_mapping_[register_virtual_field("countdown")] = [this](time::microseconds_t timestamp) -> Value {
        if (min_timestamp_ != time::INVALID_TIME) {
            time::microseconds_t diff = min_timestamp_ - timestamp;
            if (diff > 0) {
                return Value(time::us_to_s(diff));
            }
        }
        return Value();
    };

    virtual_data_mapping_[register_virtual_field("overtime")] = [this](time::microseconds_t timestamp) -> Value {
        if (max_timestamp_ != 0) {
            time::microseconds_t diff = timestamp - max_timestamp_;
            if (diff > 0) {
                return Value(time::us_to_s(diff));
            }
        }
        return Value();
    };
}

field_id_t Track::register_metadata_field(const std::string& key) {
    std::string metakey = consts::prefix::metadata + key;
    auto id = register_field(metakey, consts::mask::metadata_flag);
    log.debug("Registered new metadata field: {} with id {}", metakey, id);
    return id;
}

field_id_t Track::register_trackpoint_field(const std::string& key) {
    std::string tpkey = consts::prefix::trackpoint + key;
    auto id = register_field(tpkey, consts::mask::trackpoint_flag);
    log.debug("Registered new trackpoint field: {} with id {}", tpkey, id);

    auto lerp_id = id | consts::mask::lerp_flag;;
    field_ids_[consts::prefix::lerp + tpkey] = lerp_id;

    auto pchip_id = id | consts::mask::pchip_flag;;
    field_ids_[consts::prefix::pchip + tpkey] = pchip_id;

    return id;
}

field_id_t Track::register_segment_field(const std::string& key) {
    std::string segkey = consts::prefix::segment + key;
    auto id = register_field(segkey, consts::mask::segment_flag);
    log.debug("Registered new segment field: {} with id {}", segkey, id);
    return id;
}

field_id_t Track::register_virtual_field(const std::string& key) {
    auto id = register_field(key, consts::mask::virtual_flag);
    log.debug("Registered new virtual field: {} with id {}", key, id);
    return id;
}

field_id_t Track::register_field(const std::string& key, field_id_t mask) {
    auto id = get_field_id(key);
    if (id != INVALID_FIELD) {
        return id;
    }

    id = next_field_id_++;
    id |= mask;
    field_ids_[key] = id;

    return id;
}

time::microseconds_t Track::to_relative_time_domain(time::time_point_t timestamp) const {
    auto us = static_cast<time::microseconds_t>(
        std::chrono::duration_cast<std::chrono::microseconds>(timestamp - start_time_).count());
    return us + start_offset_;
}

} // namespace track
} // namespace telemetry
