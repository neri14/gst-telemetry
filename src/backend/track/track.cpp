#include "track.h"

#include "backend/utils/time.h"
#include <cmath>


std::string drop_ns(const std::string& name) {
    auto pos = name.rfind(':');
    return (pos == std::string::npos) ? name : name.substr(pos + 1);
}

namespace telemetry {
namespace track {
namespace consts {
    namespace mask {
        const field_id_t flags            = 0xFF000000;

        const field_id_t virtual_flag     = 0x80000000;
        const field_id_t metadata_flag    = 0x40000000;
        const field_id_t trackpoint_flag  = 0x20000000;
        const field_id_t segment_flag     = 0x10000000;
      /*   unused 0x08 flag                 0x08000000 */ 
      /*   unused 0x04 flag                 0x04000000 */
        const field_id_t lerp_flag        = 0x02000000;
        const field_id_t pchip_flag       = 0x01000000;

        namespace segment {
            const field_id_t type         = 0x00F80000; // up to 32 segment types
            const field_id_t list         = 0x00070000; // up to 8 segment lists
            const field_id_t segment      = 0x0000FF00; // up to 256 segment instances (within type-list context)
            const field_id_t field        = 0x000000FF; // up to 256 fields (within segment point/segment metadata)
        }
    }
    namespace prefix {
        const std::string metadata = "meta_";
        const std::string trackpoint = "point_";
        const std::string lerp = "lerp_";
        const std::string pchip = "pchip_";
        const std::string segment = "s_";
    } // namespace prefix
    namespace segment_list {
        const field_id_t active = 0x0;  // currently active segments
        const field_id_t prev   = 0x1;  // previously active segments
        const field_id_t next   = 0x2;  // next active segments
        const field_id_t all    = 0x3;  // all segments of this type
    }

    const int max_segment_types = 32;
    const int max_segment_instances = 256;
} // namespace consts


struct segment_field_id {
    field_id_t type;
    field_id_t list;
    field_id_t segment;
    field_id_t field;

    segment_field_id(field_id_t type, field_id_t list, field_id_t segment, field_id_t field)
        : type(type), list(list), segment(segment), field(field) {}

    segment_field_id(field_id_t fid) {
        type = (fid & consts::mask::segment::type) >> 19;
        list = (fid & consts::mask::segment::list) >> 16;
        segment = (fid & consts::mask::segment::segment) >> 8;
        field = fid & consts::mask::segment::field;
    }

    explicit operator field_id_t() const {
        return ((type << 19) & consts::mask::segment::type) |
               ((list << 16) & consts::mask::segment::list) |
               ((segment << 8) & consts::mask::segment::segment) |
               (field & consts::mask::segment::field);
    }
};

std::string uint_to_hex(uint32_t v, int width = 0, bool prefix = true, bool uppercase = true) {
    std::ostringstream ss;
    if (prefix) ss << "0x";
    ss << std::hex << (uppercase ? std::uppercase : std::nouppercase)
       << std::setw(width) << std::setfill('0') << v;
    return ss.str();
}

    // NOTE no need for segment-point - everything can be calculated or taken from trackpoints and metadata
    //      only exception being accpower

    // TODO move to markdown documentation
    //                          xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx
    //                         |--flags--|
    
    // field types:
    // virtual         0x80     1000 .... |-----------field-id------------|
    // metadata        0x40     0100 .... |-----------field-id------------|
    // trackpt         0x20     0010 .... |-----------field-id------------|
    // segment         0x10     0001 .... 

    // modifiers:
    // lerp            0x08     00.. 10..
    // pchip           0x04     00.. 01..
    // unused          0x02     .... ..1 
    // unused          0x01     .... ...1


    // segment field id layout:
    //                                     0001 ..00  TTTT TLLL NNNN NNNN  IIII IIII
    //
    // examples (not real bit values):
    // s_climb_prev_0_meta_distance        0001 0000  0000 1001 0000 0000  0001 0010
    //    type = 0x01  segment
    //    mods = 0x00  (no modifiers)
    //    type = 0x01* climb 
    //    list = 0x01  previous segments list
    //    num  = 0x00  first climb instance in prev list (most recently finished)
    //    field= 0x12* "distance" metadata field of segment
    //
    // * - value autogenerated from track data
    //
    // lerp_s_climb_active_0_point_dist    0001 1000  0000 1000 0000 0000  0001 0010
    //    type = 0x10  segment
    //    mods = 0x08  linearly interpolated
    //    type = 0x01* climb
    //    list = 0x00  current segments list
    //    num  = 0x00  first climb instance in current list (oldest start time of currently active)
    //    field= 0x12* "dist" point field within segment


    // TTTT T     - segment type identifier (up to 16 types)
    // LLL        - segment list identifier (up to 8 lists)
    // NNNN NNNN  - segment instance identifier (up to 256 instances)
    // IIII IIII  - field identifier within segment (up to 256 fields)
    // 
    // segments types (TTTT T) - mapped to TYPE in "s_TYPE_" field name prefix:
    //      auto generated from track
    //      e.g. "segment" "climb" generated by GPST in ActivitySegmentType extension
    //      in future e.g. "laps"
    //
    // segment lists (LLL):
    //     - currently active segment   (mapped to "s_TYPE_active_N_")
    //     - previous active segment    (mapped to "s_TYPE_prev_N_")
    //     - next active segment        (mapped to "s_TYPE_next_N_")
    //     - all segments               (mapped to "s_TYPE_N_")
    //
    // segment instance id (NNN NNNN) - mapped to N in field name prefix above:
    //     unique identifier for segment instance within its type-list
    //
    // suffix:
    //     - metadata: "_meta_FIELDNAME"
    //     - point data: "_point_FIELDNAME" (only relevant for "active" list)
    //
    // field id within segment (IIII IIII) - mapped to FIELDNAME above
    //     TBD for metadata generated
    //     TBD generated from track point field names within segment context
    //     TBD with cumulative values virtualized to treat segment start as zero point
    //     TBD - actually only metadata and cumulative fields make sense - rest will be taken from actual points
    //
    // example field names:
    //   s_climb_active_0_point_dist - cumulative distance since start of current climb segment
    //


Track::Track(time::microseconds_t offset): start_offset_(offset) {
    log.info("Track created with offset: {} us", offset);

    create_virtual_fields();
}

bool Track::load(const std::string& path) {
    log.info("Loading track from path: {}", path);

    pugi::xml_document doc;
    pugi::xml_parse_result result = doc.load_file(path.c_str());

    if (!result) {
        log.error("Failed to load track file: {}. Error description: {}", path, result.description());
        return false;
    }

    if (doc.children().empty()) {
        log.error("Empty track file: {}", path);
        return false;
    }

    if (std::distance(doc.children().begin(), doc.children().end()) > 1) {
        log.error("More than one root node in track file");
        return false;
    }

    pugi::xml_node root = doc.child("gpx");
    if (!root) {
        log.error("No <gpx> root node found in track file");
        return false;
    }

    bool ok = parse_gpx(root);

    return ok;
}

field_id_t Track::get_field_id(const std::string& field_name) const {
    auto it = field_ids_.find(field_name);
    if (it != field_ids_.end()) {
        return it->second;
    }
    return INVALID_FIELD;
}

Track::trackpoint_ts_view_t Track::get_trackpoint_timestamps() const {
    return std::views::keys(trackpoints_);
}

Value Track::get(const std::string& key, time::microseconds_t timestamp) const {
    field_id_t field_id = get_field_id(key);
    return get(field_id, timestamp);
}

Value Track::get(field_id_t field_id, time::microseconds_t timestamp) const {
    if (field_id == INVALID_FIELD) {
        log.debug("Invalid field id requested");
        return Value();
    }
    
    if (field_id & consts::mask::segment_flag) {
        return get_segment_data(field_id, timestamp);
    } else if (field_id & consts::mask::trackpoint_flag) {
        if (field_id & consts::mask::lerp_flag) {
            return get_lerp_trackpoint_data(field_id, timestamp);
        } else if (field_id & consts::mask::pchip_flag) {
            return get_pchip_trackpoint_data(field_id, timestamp);
        } else {
            return get_trackpoint_data(field_id, timestamp);
        }
    } else if (field_id & consts::mask::metadata_flag) {
        return get_metadata(field_id);
    } else if (field_id & consts::mask::virtual_flag) {
        return get_virtual_data(field_id, timestamp);
    } else {
        log.warning("Unparsable field id: {}", uint_to_hex(field_id));
        return Value();
    }
}

Value Track::get_metadata(field_id_t field_id) const {
    auto it = metadata_.find(field_id);
    if (it != metadata_.end()) {
        return it->second;
    }
    return Value();
}

Value Track::get_trackpoint_data(field_id_t field_id, time::microseconds_t timestamp) const {
    //TODO add caching of last accessed trackpoint (or similar) (maybe?)
    //TODO need to handle case where the data is stale?

    auto tp_it = trackpoints_.upper_bound(timestamp);

    if (tp_it != trackpoints_.begin()) {
        --tp_it;

        auto& tp_data = *(tp_it->second);
        auto field_it = tp_data.find(field_id);
        if (field_it != tp_data.end()) {
            return field_it->second;
        }
    }
    return Value();
}

Value Track::get_lerp_trackpoint_data(field_id_t field_id, time::microseconds_t timestamp) const {
    field_id_t data_field_id = field_id ^ consts::mask::lerp_flag;

    auto upper_it = trackpoints_.upper_bound(timestamp);
    if (upper_it != trackpoints_.begin() && upper_it != trackpoints_.end()) {
        auto lower_it = std::prev(upper_it);

        auto& lower_data = *(lower_it->second);
        auto& upper_data = *(upper_it->second);

        auto lower_field_it = lower_data.find(data_field_id);
        auto upper_field_it = upper_data.find(data_field_id);

        if (lower_field_it != lower_data.end() && upper_field_it != upper_data.end()) {
            Value lower_value = lower_field_it->second;
            Value upper_value = upper_field_it->second;

            if (lower_value.is_double() && upper_value.is_double()) {
                double lv = lower_value.as_double();
                double uv = upper_value.as_double();

                time::microseconds_t t0 = lower_it->first;
                time::microseconds_t t1 = upper_it->first;

                double factor = static_cast<double>(timestamp - t0) / static_cast<double>(t1 - t0);
                double interpolated_value = lv + factor * (uv - lv);

                return Value(interpolated_value);
            } else {
                log.warning("Lerp interpolation only supported for double values. Field id: {}", uint_to_hex(data_field_id));
            }
        }
        else {
            log.debug("Field id {} not found in both bounding trackpoints for lerp interpolation", uint_to_hex(data_field_id));
        }
    } else {
        log.debug("Not enough trackpoints for lerp interpolation at timestamp {}", timestamp);
    }
    return Value();
}

Value Track::get_pchip_trackpoint_data(field_id_t field_id, time::microseconds_t timestamp) const {
    field_id_t data_field_id = field_id ^ consts::mask::pchip_flag;

    auto it2 = trackpoints_.upper_bound(timestamp);
    auto it1 = (it2 != trackpoints_.begin()) ? std::prev(it2) : trackpoints_.end();
    auto it0 = (it1 != trackpoints_.begin()) ? std::prev(it1) : trackpoints_.end();
    auto it3 = (it2 != trackpoints_.end()) ? std::next(it2) : trackpoints_.end();

    if (it0 == trackpoints_.end() || it1 == trackpoints_.end() ||
        it2 == trackpoints_.end() || it3 == trackpoints_.end()) {
        log.debug("Not enough trackpoints for PCHIP interpolation at timestamp {}", timestamp);
        return Value();
    }

    auto data_it0 = it0->second->find(data_field_id);
    auto data_it1 = it1->second->find(data_field_id);
    auto data_it2 = it2->second->find(data_field_id);
    auto data_it3 = it3->second->find(data_field_id);

    if (data_it0 == it0->second->end() || data_it1 == it1->second->end() ||
        data_it2 == it2->second->end() || data_it3 == it3->second->end()) {
        log.debug("Field id {} not found in all bounding trackpoints for PCHIP interpolation", uint_to_hex(data_field_id));
        return Value();
    }

    if (it0->first >= it1->first || it1->first >= it2->first || it2->first >= it3->first) {
        log.error("Timestamps for PCHIP interpolation are not strictly increasing");
        return Value();
    }

    if (timestamp < it1->first || timestamp > it2->first) {
        log.error("Timestamp {} for PCHIP interpolation is out of bounds [{}, {}]", timestamp, it1->first, it2->first);
        return Value();
    }

    double t = time::us_to_s(timestamp);

    double t0 = time::us_to_s(it0->first);
    double t1 = time::us_to_s(it1->first);
    double t2 = time::us_to_s(it2->first);
    double t3 = time::us_to_s(it3->first);

    if (t == t1) {
        return Value(data_it1->second);
    }
    if (t == t2) {
        return Value(data_it2->second);
    }

    double x0 = data_it0->second.as_double();
    double x1 = data_it1->second.as_double();
    double x2 = data_it2->second.as_double();
    double x3 = data_it3->second.as_double();

    //pchip interpolation algorithm

    // intervals
    double h0 = t1 - t0;
    double h1 = t2 - t1;
    double h2 = t3 - t2;

    // secant slopes
    double d0 = (x1 - x0) / h0;
    double d1 = (x2 - x1) / h1;
    double d2 = (x3 - x2) / h2;

    // derivative at t1
    double m1 = 0;
    if (d0 * d1 > 0) {
        m1 = (h0 + h1) / ((h1 / d0) + (h0 / d1));
    }

    // defivative at t2
    double m2 = 0;
    if (d1 * d2 > 0) {
        m2 = (h1 + h2) / ((h2 / d1) + (h1 / d2));
    }

    // normalized parameter
    double s = (t - t1) / h1;

    // hermite basiss
    double h00 = 2 * std::pow(s, 3) - 3 * std::pow(s, 2) + 1;
    double h10 = std::pow(s, 3) - 2 * std::pow(s, 2) + s;
    double h01 = -2 * std::pow(s, 3) + 3 * std::pow(s, 2);
    double h11 = std::pow(s, 3) - std::pow(s, 2);

    // interpolated value
    double x = h00 * x1 + h10 * h1 * m1 + h01 * x2 + h11 * h1 * m2;

    return Value(x);
}

Value Track::get_virtual_data(field_id_t field_id, time::microseconds_t timestamp) const {
    auto it = virtual_data_mapping_.find(field_id);
    if (it != virtual_data_mapping_.end()) {
        return it->second(timestamp);
    }

    log.warning("Unknown virtual field id: {}", uint_to_hex(field_id));
    return Value();
}

bool Track::parse_gpx(pugi::xml_node node) {
    log.info("Parsing GPX root node");

    bool ok = true;

    pugi::xml_node metadata = node.child("metadata");
    if (metadata) {
        ok = parse_metadata(metadata) && ok;
    }

    pugi::xml_node trk = node.child("trk");
    if (trk) {
        ok = parse_trk(trk) && ok;
    }

    return ok;
}

Value Track::get_segment_data(field_id_t field_id, time::microseconds_t timestamp) const {
    field_id_t flags = field_id & consts::mask::flags;
    segment_field_id sfid(field_id);

    switch (sfid.list) {
        case consts::segment_list::active:
            {
                std::vector<field_id_t> segments = get_active_segments_ordered(sfid.type, timestamp);
                if (segments.size() > sfid.segment) {
                    sfid.segment = segments[sfid.segment];
                    sfid.list = consts::segment_list::all;
                } else {
                    log.debug("Active segment index {} out of range for type {}", sfid.segment, uint_to_hex(sfid.type));
                    return Value();
                }
            }
            break;
        case consts::segment_list::prev:
            {
                std::vector<field_id_t> segments = get_prev_segments_ordered(sfid.type, timestamp);
                if (segments.size() > sfid.segment) {
                    sfid.segment = segments[sfid.segment];
                    sfid.list = consts::segment_list::all;
                } else {
                    log.debug("Prev segment index {} out of range for type {}", sfid.segment, uint_to_hex(sfid.type));
                    return Value();
                }
            }
            break;
        case consts::segment_list::next:
            {
                std::vector<field_id_t> segments = get_next_segments_ordered(sfid.type, timestamp);
                if (segments.size() > sfid.segment) {
                    sfid.segment = segments[sfid.segment];
                    sfid.list = consts::segment_list::all;
                } else {
                    log.debug("Next segment index {} out of range for type {}", sfid.segment, uint_to_hex(sfid.type));
                    return Value();
                }
            }
            break;
        case consts::segment_list::all:
            //no mapping required for "all" list
            break;
        default:
            log.warning("Invalid segment list in field id: {}", uint_to_hex(field_id));
            return Value();
    }

    field_id_t real_fid = static_cast<field_id_t>(sfid) | flags;

    if (real_fid & consts::mask::metadata_flag) {
        return get_segment_metadata(real_fid);
    }

    log.warning("Segment field data not possible to be retrieved for field {} at {} (mapped to {})",
                uint_to_hex(field_id), std::format("{}", timestamp), uint_to_hex(real_fid));
    return Value();
}

Value Track::get_segment_metadata(field_id_t field_id) const {//metadata_[full_field_id] = value;
    auto it = metadata_.find(field_id);
    if (it != metadata_.end()) {
        return it->second;
    }
    log.warning("Segment metadata field id not found: {}", uint_to_hex(field_id));
    return Value();
}


bool Track::parse_metadata(pugi::xml_node node) {
    log.info("Parsing GPX metadata");

    auto bounds = node.child("bounds");
    if (bounds) {
        auto minlat = bounds.attribute("minlat");
        if (minlat) {
            double value = minlat.as_double();
            log.debug("Metadata minlat: {}", value);
            store_metadata("minlat", value);
        }
        auto maxlat = bounds.attribute("maxlat");
        if (maxlat) {
            double value = maxlat.as_double();
            log.debug("Metadata maxlat: {}", value);
            store_metadata("maxlat", value);
        }
        auto minlon = bounds.attribute("minlon");
        if (minlon) {
            double value = minlon.as_double();
            log.debug("Metadata minlon: {}", value);
            store_metadata("minlon", value);
        }
        auto maxlon = bounds.attribute("maxlon");
        if (maxlon) {
            double value = maxlon.as_double();
            log.debug("Metadata maxlon: {}", value);
            store_metadata("maxlon", value);
        }
    }

    auto name = node.child("name");
    if (name) {
        log.debug("Metadata name: {}", name.text().as_string());
        store_metadata("name", std::string(name.text().as_string()));
    }

    return true;
}

/* segments with start_time <= timestamp <= end_time ordered by start_time ascending */
std::vector<field_id_t> Track::get_active_segments_ordered(
                    field_id_t segment_type, time::microseconds_t timestamp) const {
    std::vector<field_id_t> segments;

    for (auto idx : segments_ordered_by_start_time_.at(segment_type)) {
        auto times = segments_lut_.at(segment_type).at(idx);
        time::microseconds_t start_us = to_relative_time_domain(times.first);
        time::microseconds_t end_us = to_relative_time_domain(times.second);

        if (start_us <= timestamp && timestamp <= end_us) {
            segments.push_back(idx);
        }
    }

    return segments;
}

/* segments with end_time < timestamp ordered by end_time descending */
std::vector<field_id_t> Track::get_prev_segments_ordered(
                    field_id_t segment_type, time::microseconds_t timestamp) const {
    std::vector<field_id_t> segments;

    for (auto it = segments_ordered_by_end_time_.at(segment_type).rbegin();
         it != segments_ordered_by_end_time_.at(segment_type).rend(); ++it) {
        auto idx = *it;
        auto times = segments_lut_.at(segment_type).at(idx);
        time::microseconds_t end_us = to_relative_time_domain(times.second);

        if (end_us < timestamp) {
            segments.push_back(idx);
        }
    }

    return segments;
}

/* segments with start_time > timestamp ordered by start_time ascending */
std::vector<field_id_t> Track::get_next_segments_ordered(
                    field_id_t segment_type, time::microseconds_t timestamp) const {
    std::vector<field_id_t> segments;

    for (auto idx : segments_ordered_by_start_time_.at(segment_type)) {
        auto times = segments_lut_.at(segment_type).at(idx);
        time::microseconds_t start_us = to_relative_time_domain(times.first);

        if (start_us > timestamp) {
            segments.push_back(idx);
        }
    }

    return segments;
}

bool Track::parse_trk(pugi::xml_node node) {
    log.info("Parsing GPX track");

    auto name = node.child("name");
    if (name) {
        log.debug("Track name: {}", name.text().as_string());
        store_metadata("name", std::string(name.text().as_string()));
    }
    auto src = node.child("src");
    if (src) {
        log.debug("Track src: {}", src.text().as_string());
        store_metadata("src", std::string(src.text().as_string()));
    }
    auto type = node.child("type");
    if (type) {
        log.debug("Track type: {}", type.text().as_string());
        store_metadata("type", std::string(type.text().as_string()));
    }

    start_time_ = find_start_time(node.children("trkseg"));
    if (start_time_ == time::INVALID_TIME_POINT) {
        log.error("Failed to find valid start timestamp in track");
        return false;
    }
    log.info("Track start time: {}", std::format("{}", start_time_));

    bool ok = true;

    auto extensions = node.child("extensions");
    if (extensions) {
        ok = parse_trk_ext(extensions) && ok;
    }

    for (auto trkseg: node.children("trkseg")) {
        ok = parse_trkseg(trkseg) && ok;
    }

    return ok;
}

time::time_point_t Track::find_start_time(
                pugi::xml_object_range<pugi::xml_named_node_iterator> trksegs) {
    time::time_point_t st = time::INVALID_TIME_POINT;
    for (auto trkseg: trksegs) {
        for (auto trkpt : trkseg.children("trkpt")) {
            if (trkpt.child("time")) {
                std::string time_str = trkpt.child("time").text().as_string();
                auto timestamp = time::parse_iso8601(time_str);
                if (timestamp != time::INVALID_TIME_POINT) {
                    if (st == time::INVALID_TIME_POINT || timestamp < st) {
                        st = timestamp;
                    }
                }
            }
        }
    }
    return st;
}

bool Track::parse_trk_ext(pugi::xml_node node) {
    log.info("Parsing GPX track extensions");
    bool ok = true;
    
    for (pugi::xml_node child : node.children()) {
        if (std::string(child.name()).ends_with("ActivityTrackExtension")) {
            ok = parse_trk_ext_atx(child) && ok;
        } else if (std::string(child.name()).ends_with("ActivitySegmentsExtension")) {
            ok = parse_trk_ext_asx(child) && ok;
        } else {
            log.info("Ignoring unknown track extension: {}", child.name());
        }
    }

    return ok;
}

bool Track::parse_trk_ext_atx(pugi::xml_node node) {
    log.info("Parsing GPX ActivityTrackExtension");
    bool ok = true;

    int cnt = 0;
    for (pugi::xml_node child : node.children()) {
        std::string key =drop_ns(child.name());
        double value = child.text().as_double();

        log.debug("Metadata: {} = {}", key, value);
        store_metadata(key, value);
        cnt++;
    }
    log.info("Parsed {} ActivityTrackExtension fields", cnt);

    return ok;
}

bool Track::parse_trk_ext_asx(pugi::xml_node node) {
    log.info("Parsing GPX ActivitySegmentsExtension");
    bool ok = true;

    for (pugi::xml_node child : node.children()) {
        std::string key = drop_ns(child.name());
        if (key == "segment") {
            ok = parse_trk_ext_asx_segment(child) && ok;
        } else {
            log.info("Ignoring unknown ActivitySegmentsExtension child: {}", key);
        }
    }

    generate_sorted_segment_lists();
    generate_segment_metadata_field_aliases();

    return ok;
}

//TODO refactor into subfunctions?
bool Track::parse_trk_ext_asx_segment(pugi::xml_node node) {
    log.info("Parsing GPX segment");
    bool ok = true;

    std::string type = "unknown";
    time::time_point_t start_time = time::INVALID_TIME_POINT;
    time::time_point_t end_time = time::INVALID_TIME_POINT;

    std::map<std::string, Value> metadata;

    for (pugi::xml_node child : node.children()) {
        std::string key = drop_ns(child.name());

        if (key == "name") {
            std::string name = child.text().as_string();
            log.info("  segment name: {}", name);
            metadata[key] = Value(name);
        } else if (key == "source") {
            std::string source = child.text().as_string();
            log.info("  segment source: {}", source);
            metadata[key] = Value(source);
        } else if (key == "type") {
            type = child.text().as_string();
            log.info("  segment type: {}", type);
            metadata[key] = Value(type);
        } else if (key == "starttime") {
            start_time = time::parse_iso8601(child.text().as_string());
            log.info("  segment start time: {}", std::format("{}", start_time));
            metadata[key] = Value(start_time);
        } else if (key == "endtime") {
            end_time = time::parse_iso8601(child.text().as_string());
            log.info("  segment end time: {}", std::format("{}", end_time));
            metadata[key] = Value(end_time);
        } else {
            double value = child.text().as_double();
            log.debug("  segment metadata: {} = {}", key, value);
            metadata[key] = Value(value);
        }
    }

    if (start_time == time::INVALID_TIME_POINT || end_time == time::INVALID_TIME_POINT) {
        log.warning("Segment missing valid start or end time");
        return false;
    }

    // register segment type if new
    field_id_t type_id = INVALID_FIELD;
    if (segment_types_.find(type) == segment_types_.end()) {
        type_id = static_cast<field_id_t>(segment_types_.size());
        segment_types_[type] = type_id;
        log.info("Registered new segment type: {} with id {}", type, uint_to_hex(type_id));
    } else {
        type_id = segment_types_[type];
    }

    // add segment to lookup table
    if (segments_lut_.find(type_id) == segments_lut_.end()) {
        segments_lut_[type_id] = {};
    }
    field_id_t instance_idx = static_cast<field_id_t>(segments_lut_[type_id].size());
    segments_lut_[type_id][instance_idx] = {start_time, end_time};
    // add index to metadata
    metadata["index"] = Value(static_cast<double>(instance_idx));

    for (const auto& [key, value] : metadata) {
        std::string field_name = "s_" + type + "_" + std::to_string(instance_idx) + "_" + key;
        log.debug("Storing segment metadata field: {} = {}", field_name, value.as_string());
        store_metadata(field_name, value);
    }

    for (const auto& [key, value] : metadata) {
        std::string partial_name = "meta_" + key; // meta_FIELDNAME

        // register field id within segment metadata if new
        field_id_t fid = INVALID_FIELD;
        if (segment_metadata_partial_field_ids_.find(partial_name) == segment_metadata_partial_field_ids_.end()) {
            fid = next_segment_metadata_field_id_++;
            segment_metadata_partial_field_ids_[partial_name] = fid;
        } else {
            fid = segment_metadata_partial_field_ids_[partial_name];
        }

        segment_field_id sfid(type_id,                   // segment type
                              consts::segment_list::all, // segment list
                              instance_idx,              // segment instance
                              fid);                      // field id within segment metadata

        // FFFF FFFF  TTTT TLLL  NNNN NNNN  IIII IIII
        // 0101 0000  tttt t011  nnnn nnnn  iiii iiii
        //
        // 0101 0000 - segment flag + metadata flag
        // tttt t    - segment type (auto assigned above)
        // 011       - all segments list (consts::segment_list::all == 0x3)
        // nnnn nnnn - segment instance (auto assigned above)
        // iiii iiii - field id within segment metadata (auto assigned above)
        field_id_t full_field_id = static_cast<field_id_t>(sfid) | consts::mask::segment_flag | consts::mask::metadata_flag;

        std::string segment_key = consts::prefix::segment + type + "_" + std::to_string(instance_idx) + "_"; // s_TYPE_N_
        std::string full_field_name = segment_key + partial_name; // s_TYPE_N_meta_FIELDNAME

        if (field_ids_.find(full_field_name) != field_ids_.end()) {
            log.warning("Segment field id already exists for field name: {} with id {}", full_field_name, uint_to_hex(field_ids_[full_field_name]));
            log.warning("While trying to assign id {}", uint_to_hex(full_field_id));
            ok = false;
            continue;
        }
        log.debug("Registered segment field id: {} = {}", full_field_name, uint_to_hex(full_field_id));
        field_ids_[full_field_name] = full_field_id;

        // store segment metadata
        metadata_[full_field_id] = value;
    }

    return ok;
}

void Track::generate_sorted_segment_lists() {
    for (const auto& [type_id, instances] : segments_lut_) {
        segments_ordered_by_start_time_[type_id] = {};
        segments_ordered_by_end_time_[type_id] = {};

        for (const auto& [instance_idx, _] : instances) {
            segments_ordered_by_start_time_[type_id].push_back(instance_idx);
            segments_ordered_by_end_time_[type_id].push_back(instance_idx);
        }

        // sort by start time
        std::sort(segments_ordered_by_start_time_[type_id].begin(),
                  segments_ordered_by_start_time_[type_id].end(),
                  [this, type_id](field_id_t a, field_id_t b) {
                      const auto& time_pair_a = segments_lut_.at(type_id).at(a);
                      const auto& time_pair_b = segments_lut_.at(type_id).at(b);
                      return time_pair_a.first < time_pair_b.first;
                  });
        // sort by end time
        std::sort(segments_ordered_by_end_time_[type_id].begin(),
                  segments_ordered_by_end_time_[type_id].end(),
                  [this, type_id](field_id_t a, field_id_t b) {
                      const auto& time_pair_a = segments_lut_.at(type_id).at(a);
                      const auto& time_pair_b = segments_lut_.at(type_id).at(b);
                      return time_pair_a.second < time_pair_b.second;
                  });
    }
}

void Track::generate_segment_metadata_field_aliases() {
    for (const auto& [type, type_id] : segment_types_) {
            for (const auto& [instance_idx, _] : segments_lut_[type_id]) {
                for (const auto& [partial_name, fid] : segment_metadata_partial_field_ids_) {
                    log.debug("Generating segment metadata field aliases for type: {}, instance: {}, field partial name: {}",
                              type, uint_to_hex(instance_idx), partial_name);

                    for (auto [list_name, list_id] : {std::make_pair("active", consts::segment_list::active),
                                                      std::make_pair("prev",   consts::segment_list::prev),
                                                      std::make_pair("next",   consts::segment_list::next)}) {
                        
                        segment_field_id sfid(type_id, list_id, instance_idx, fid);
                        field_id_t full_field_id = static_cast<field_id_t>(sfid) | consts::mask::segment_flag | consts::mask::metadata_flag;

                        std::string segment_key = consts::prefix::segment + type + "_" + list_name + "_" + std::to_string(instance_idx) + "_"; // s_TYPE_LIST_N_
                        std::string full_field_name = segment_key + partial_name; // s_TYPE_LIST_N_meta_FIELDNAME

                        log.debug("Registered segment field id alias: {} = {}", full_field_name, uint_to_hex(full_field_id));
                        field_ids_[full_field_name] = full_field_id;
                    }
            }
        }
    }
}

bool Track::parse_trkseg(pugi::xml_node node) {
    log.info("Parsing GPX track segment");
    bool ok = true;

    for (pugi::xml_node trkpt : node.children("trkpt")) {
        ok = parse_trkpt(trkpt) && ok;
    }

    return ok;
}

bool Track::parse_trkpt(pugi::xml_node node) {
    log.debug("Parsing GPX track point");

    if (!node.attribute("lat") || !node.attribute("lon")) {
        log.warning("Track point missing lat or lon attribute");
        return false;
    }
    if (!node.child("time")) {
        log.warning("Track point missing time value");
        return false;
    }

    std::string time_str = node.child("time").text().as_string();
    auto timestamp = time::parse_iso8601(time_str);
    if (timestamp == time::INVALID_TIME_POINT) {
        log.warning("Failed to parse track point time: {}", time_str);
        return false;
    }
    log.debug("Track point time: {}", timestamp);

    time::microseconds_t ts = to_relative_time_domain(timestamp);

    store_trackpoint_data(ts, "time", Value(timestamp));

    double lat = node.attribute("lat").as_double();
    double lon = node.attribute("lon").as_double();
    store_trackpoint_data(ts, "lat", Value(lat));
    store_trackpoint_data(ts, "lon", Value(lon));
    log.debug("Track point lat: {}, lon: {}", lat, lon);

    for (pugi::xml_node child : node.children()) {
        std::string key = drop_ns(child.name());
        if (key == "time") {
            continue; // processed separately
        }
        if (key == "extensions") {
            for (pugi::xml_node ext_child : child.children()) {
                std::string ext_key = drop_ns(ext_child.name());
                if (ext_key == "TrackPointExtension" || ext_key == "ActivityTrackPointExtension") {
                    for (pugi::xml_node ext_data : ext_child.children()) {
                        std::string data_key = drop_ns(ext_data.name());
                        if (ext_data.text().empty()) {
                            log.debug("Track point extension data: {} has no data", data_key);
                            continue; // no data
                        }
                        double value = ext_data.text().as_double();
                        log.debug("Track point extension data: {} = {}", data_key, value);
                        store_trackpoint_data(ts, data_key, Value(value));
                    }
                } else if (ext_key == "power") { // special case for Strava gpx files
                    if (ext_child.text().empty()) {
                        log.debug("Track point extension data: power has no data");
                        continue; // no data
                    }
                    double value = ext_child.text().as_double();
                    log.debug("Track point extension data: power = {}", value);
                    store_trackpoint_data(ts, "power", Value(value));
                } else {
                    log.debug("Ignoring unknown track point extension: {}", ext_key);
                }
            }
            continue; // processed
        }
        if (child.text().empty()) {
            log.debug("Track point data: {} has no data", key);
            continue; // no data
        }
        double value = child.text().as_double();
        log.debug("Track point data: {} = {}", key, value);
        store_trackpoint_data(ts, key, Value(value));
    }

    return true;
}

bool Track::store_metadata(const std::string& key, const Value& value) {
    field_id_t field_id = register_metadata_field(key);
    metadata_[field_id] = value;
    return true;
}

bool Track::store_trackpoint_data(time::microseconds_t timestamp,
                                  const std::string& key, const Value& value) {
    std::shared_ptr<std::map<field_id_t, Value>> tp_data;
    
    auto it = trackpoints_.find(timestamp);
    if (it != trackpoints_.end()) {
        tp_data = it->second;
    } else {
        tp_data = std::make_shared<std::map<field_id_t, Value>>();
        trackpoints_[timestamp] = tp_data;

        if (timestamp < min_timestamp_) {
            min_timestamp_ = timestamp;
        }
        if (timestamp > max_timestamp_) {
            max_timestamp_ = timestamp;
        }
    }

    field_id_t field_id = register_trackpoint_field(key);
    (*tp_data)[field_id] = value;
    return true;
}

void Track::create_virtual_fields() {
    virtual_data_mapping_[register_virtual_field("timestamp")] = [this](time::microseconds_t timestamp) -> Value {
        time::time_point_t tp = start_time_ + std::chrono::microseconds(timestamp - start_offset_);
        return Value(tp);
    };

    virtual_data_mapping_[register_virtual_field("video_time")] = [this](time::microseconds_t timestamp) -> Value {
        return Value(time::us_to_s(timestamp));
    };

    virtual_data_mapping_[register_virtual_field("time_elapsed")] = [this](time::microseconds_t timestamp) -> Value {
        if (min_timestamp_ != time::INVALID_TIME) {
            return Value(time::us_to_s(timestamp - min_timestamp_));
        } else {
            return Value();
        }
    };

    virtual_data_mapping_[register_virtual_field("time_remaining")] = [this](time::microseconds_t timestamp) -> Value {
        if (max_timestamp_ != 0) {
            return Value(time::us_to_s(max_timestamp_ - timestamp));
        } else {
            return Value();
        }
    };

    virtual_data_mapping_[register_virtual_field("active")] = [this](time::microseconds_t timestamp) -> Value {
        if (min_timestamp_ != time::INVALID_TIME && max_timestamp_ != 0) {
            return Value(timestamp >= min_timestamp_ && timestamp <= max_timestamp_);
        } else {
            return Value(false);
        }
    };

    virtual_data_mapping_[register_virtual_field("countdown")] = [this](time::microseconds_t timestamp) -> Value {
        if (min_timestamp_ != time::INVALID_TIME) {
            time::microseconds_t diff = min_timestamp_ - timestamp;
            if (diff > 0) {
                return Value(time::us_to_s(diff));
            }
        }
        return Value();
    };

    virtual_data_mapping_[register_virtual_field("overtime")] = [this](time::microseconds_t timestamp) -> Value {
        if (max_timestamp_ != 0) {
            time::microseconds_t diff = timestamp - max_timestamp_;
            if (diff > 0) {
                return Value(time::us_to_s(diff));
            }
        }
        return Value();
    };
}

field_id_t Track::register_metadata_field(const std::string& key) {
    std::string metakey = consts::prefix::metadata + key;
    auto id = register_field(metakey, consts::mask::metadata_flag);
    log.debug("Registered new metadata field: {} with id {}", metakey, uint_to_hex(id));
    return id;
}

field_id_t Track::register_trackpoint_field(const std::string& key) {
    std::string tpkey = consts::prefix::trackpoint + key;
    auto id = register_field(tpkey, consts::mask::trackpoint_flag);
    log.debug("Registered new trackpoint field: {} with id {}", tpkey, uint_to_hex(id));

    auto lerp_id = id | consts::mask::lerp_flag;;
    field_ids_[consts::prefix::lerp + tpkey] = lerp_id;

    auto pchip_id = id | consts::mask::pchip_flag;;
    field_ids_[consts::prefix::pchip + tpkey] = pchip_id;

    return id;
}

field_id_t Track::register_virtual_field(const std::string& key) {
    auto id = register_field(key, consts::mask::virtual_flag);
    log.debug("Registered new virtual field: {} with id {}", key, uint_to_hex(id));
    return id;
}

field_id_t Track::register_field(const std::string& key, field_id_t mask) {
    auto id = get_field_id(key);
    if (id != INVALID_FIELD) {
        return id;
    }

    id = next_field_id_++;
    id |= mask;
    field_ids_[key] = id;

    return id;
}

time::microseconds_t Track::to_relative_time_domain(time::time_point_t timestamp) const {
    auto us = static_cast<time::microseconds_t>(
        std::chrono::duration_cast<std::chrono::microseconds>(timestamp - start_time_).count());
    return us + start_offset_;
}

} // namespace track
} // namespace telemetry
